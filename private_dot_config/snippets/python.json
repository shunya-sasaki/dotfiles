{
  "Pydantic Data Model": {
    "prefix": "py-data-model",
    "description": "Pydantic data model with validation and serialization.",
    "body": [
      "\"\"\"This module define ${1:ModelClass}.\"\"\"",
      "",
      "from __future__ import annotations",
      "",
      "from pydantic import BaseModel",
      "from pydantic import ConfigDict",
      "",
      "from ${2:package_name}.utils import FormatConverter",
      "",
      "",
      "class ${1:ModelClass}(BaseModel):",
      "    \"\"\"${1: ModelClass} data model.",
      "",
      "    Args:",
      "",
      "    \"\"\"",
      "",
      "    model_config = ConfigDict(",
      "        alias_generator=FormatConverter.snake_to_camel, populate_by_name=True",
      "    )",
      ""
    ]
  },
  "GitVersion": {
    "prefix": "py-git-version",
    "description": "Define GitVersion class that manages git operations.",
    "body": [
      "\"\"\"This module define GitVersion class.\"\"\"",
      "",
      "import re",
      "import shutil",
      "import subprocess",
      "from importlib.metadata import version as prodcut_version",
      "from importlib.resources import as_file",
      "from importlib.resources import files",
      "from pathlib import Path",
      "",
      "",
      "class GitVersion:",
      "    \"\"\"Class to manage git operations.\"\"\"",
      "",
      "    @classmethod",
      "    def _execute(cls, args: list[str]) -> str:",
      "        out = subprocess.run(",
      "            args=args, capture_output=True, text=True, check=True",
      "        ).stdout.strip()",
      "        return out",
      "",
      "    @classmethod",
      "    def package_name(cls) -> str:",
      "        \"\"\"Return the package name.\"\"\"",
      "        origin_path = Path(__file__)",
      "        parents = origin_path.parents",
      "        package_name = origin_path.name",
      "        is_package_found = False",
      "        for parent in parents:",
      "            if parent.name in [\"src\", \"site-packages\"]:",
      "                is_package_found = True",
      "                break",
      "            else:",
      "                package_name = parent.name",
      "        if not is_package_found:",
      "            raise RuntimeError(",
      "                \"Package directory should be within `src` \"",
      "                + \"or `site-packages` directory.\"",
      "            )",
      "        return package_name",
      "",
      "    @classmethod",
      "    def is_product(cls) -> bool:",
      "        \"\"\"Check if the package is a product.\"\"\"",
      "        package_name = cls.package_name()",
      "        traverse = files(package_name)",
      "        context_manager = as_file(traverse)",
      "        with context_manager as path:",
      "            package_path = Path(path)",
      "        parent = package_path.parent.name",
      "        if parent == \"site-packages\":",
      "            is_product = True",
      "        else:",
      "            is_product = False",
      "        return is_product",
      "",
      "    @classmethod",
      "    def git_available(cls) -> bool:",
      "        \"\"\"Check if git is available in the system.\"\"\"",
      "        path = shutil.which(\"git\")",
      "        return path is not None",
      "",
      "    @classmethod",
      "    def version(cls) -> str:",
      "        \"\"\"Return the current git version.\"\"\"",
      "        version = \"unknown\"",
      "        if cls.is_product():",
      "            version = cls._version_from_metadata()",
      "        if version == \"unknown\" and cls.git_available():",
      "            out = cls._execute([\"git\", \"describe\", \"--tags\", \"--dirty\"])",
      "            describes = out.split(\"-\")",
      "            semantic_version = re.sub(r\"^v\", \"\", describes[0])",
      "            if len(describes) > 1:",
      "                commit_count = int(describes[1])",
      "                commit_hash = re.sub(r\"^g\", \"\", describes[2])",
      "                is_dirty = describes[-1] == \"dirty\"",
      "            else:",
      "                commit_count = 0",
      "                commit_hash = \"\"",
      "                is_dirty = False",
      "            major, minor, patch = semantic_version.split(\".\")",
      "            if commit_count == 0 and not is_dirty:",
      "                version = f\"{major}.{minor}.{patch}\"",
      "            elif is_dirty:",
      "                version = (",
      "                    f\"{major}.{minor}.{patch}\"",
      "                    + f\".post{commit_count}.dev0+{commit_hash}\"",
      "                )",
      "            else:",
      "                version = (",
      "                    f\"{major}.{minor}.{patch}\"",
      "                    + f\".post{commit_count}+{commit_hash}\"",
      "                )",
      "        return version",
      "",
      "    @classmethod",
      "    def current_branch(cls) -> str:",
      "        \"\"\"Return the current git branch.\"\"\"",
      "        out = cls._execute([\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"])",
      "        return out",
      "",
      "    @classmethod",
      "    def last_commit_message(cls) -> str:",
      "        \"\"\"Return the last commit message.\"\"\"",
      "        out = cls._execute([\"git\", \"log\", \"-1\", \"--pretty=%B\"])",
      "        return out",
      "",
      "    @classmethod",
      "    def delete_tag(cls, tag: str) -> None:",
      "        \"\"\"Delete a git tag.\"\"\"",
      "        cls._execute([\"git\", \"tag\", \"-d\", tag])",
      "",
      "    @classmethod",
      "    def add_tag(cls, tag: str, message: str = \"\") -> None:",
      "        \"\"\"Add a git tag.\"\"\"",
      "        if message:",
      "            args = [\"git\", \"tag\", \"-a\", tag, \"-m\", message]",
      "        else:",
      "            args = [\"git\", \"tag\", tag]",
      "        cls._execute(args)",
      "",
      "    @classmethod",
      "    def add_file(cls, file_name: str) -> None:",
      "        \"\"\"Add a file to git.\"\"\"",
      "        cls._execute([\"git\", \"add\", file_name])",
      "",
      "    @classmethod",
      "    def push(cls, verify: bool = True) -> None:",
      "        \"\"\"Push changes to git.\"\"\"",
      "        if verify:",
      "            args = [\"git\", \"push\"]",
      "        else:",
      "            args = [\"git\", \"push\", \"--no-verify\"]",
      "        cls._execute(args)",
      "",
      "    @classmethod",
      "    def push_tags(cls) -> None:",
      "        \"\"\"Push tags to git.\"\"\"",
      "        cls._execute([\"git\", \"push\", \"--tags\"])",
      "",
      "    @classmethod",
      "    def commit(",
      "        cls, message: str, verify: bool = True, allow_empty: bool = False",
      "    ) -> None:",
      "        \"\"\"Commit changes to git.\"\"\"",
      "        if allow_empty:",
      "            args = [\"git\", \"commit\", \"--allow-empty\", \"-m\", message]",
      "        else:",
      "            args = [\"git\", \"commit\", \"-m\", message]",
      "        if not verify:",
      "            args.append(\"--no-verify\")",
      "        cls._execute(args)",
      "",
      "    @classmethod",
      "    def release(cls) -> None:",
      "        \"\"\"Release the current version.\"\"\"",
      "        if current_branch := cls.current_branch() != \"main\":",
      "            raise RuntimeError(",
      "                f\"Your current branch is '{current_branch}'. \"",
      "                \"Release can only be performed from the 'main' branch.\"",
      "            )",
      "        version = cls.version()",
      "        if version == \"unknown\":",
      "            raise RuntimeError(\"Cannot release: version is unknown.\")",
      "        if \"dev0\" in version:",
      "            raise RuntimeError(",
      "                \"Cannot release: version is a development version.\"",
      "            )",
      "        if \"post\" in version:",
      "            raise RuntimeError(",
      "                \"Cannot release: version is a post-release version.\"",
      "            )",
      "        cls.delete_tag(\"v\" + version)",
      "        cls.commit(f\"Release v{version}\", verify=False, allow_empty=True)",
      "        cls.add_tag(\"v\" + version)",
      "        cls.push_tags()",
      "        cls.push(verify=False)",
      "",
      "    @classmethod",
      "    def build(cls) -> None:",
      "        \"\"\"Build the package.\"\"\"",
      "        if current_branch := cls.current_branch() != \"main\":",
      "            raise RuntimeError(",
      "                f\"Your current branch is '{current_branch}'. \"",
      "                \"Release can only be performed from the 'main' branch.\"",
      "            )",
      "        last_commit_message = cls.last_commit_message()",
      "        if not last_commit_message.startswith(\"Release v\"):",
      "            raise RuntimeError(",
      "                \"Cannot build: repository is not in a release state.\"",
      "            )",
      "        cls._execute([\"uv\", \"build\"])",
      "",
      "    @classmethod",
      "    def _version_from_metadata(cls) -> str:",
      "        \"\"\"Get the version from the package metadata.\"\"\"",
      "        package_name = cls.package_name()",
      "        try:",
      "            version = prodcut_version(package_name)",
      "        except Exception as e:",
      "            version = \"unknown\"",
      "        return version"
    ]
  },
  "Flake8 rules": {
    "prefix": "py-flake8",
    "description": "Flake8 rules that should be written in the .flake8 file.",
    "body": [
      "[flake8]",
      "extend-ignore = W503"
    ]
  },
  "FastAPI main template": {
    "prefix": "py-fastapi-main",
    "description": "FastAPI main application template.",
    "body": [
      "import os",
      "from contextlib import asynccontextmanager",
      "from pathlib import Path",
      "",
      "import uvicorn",
      "from fastapi import APIRouter",
      "from fastapi import FastAPI",
      "from fastapi.middleware.cors import CORSMiddleware",
      "from fastapi.requests import Request",
      "from fastapi.responses import HTMLResponse",
      "from fastapi.staticfiles import StaticFiles",
      "from fastapi.templating import Jinja2Templates",
      "",
      "from ${1:package_name}.models import AppConfig",
      "from ${1:package_name}.utils import CustomLogger",
      "from ${1:package_name}.utils import GitVersion",
      "",
      "config = AppConfig.from_jsonfile(\"config.json\")",
      "",
      "",
      "@asynccontextmanager",
      "async def lifespan(app: FastAPI):",
      "    \"\"\"Lifespan event for the FastAPI application.\"\"\"",
      "    if Path(\"./js\").exists():",
      "        app.mount(\"/js\", StaticFiles(directory=\"./js\"), name=\"\")",
      "    yield",
      "",
      "app = FastAPI(lifespan=lifespan, version=)",
      "app.add_middleware(",
      "    CORSMiddleware,",
      "    allow_origins=[\"*\"],",
      "    allow_credentials=True,",
      "    allow_methods=[\"*\"],",
      "    allow_headers=[\"*\"],",
      ")",
      "routers: list[APIRouter] = []",
      "for router in routers:",
      "    app.include_router(router)",
      "",
      "",
      "@app.get(\"/\", response_class=HTMLResponse)",
      "def index_page(request: Request):",
      "    \"\"\"Render the index page.\"\"\"",
      "    if Path(\"./js\").exists():",
      "        templates = Jinja2Templates(directory=\"./js\")",
      "        return templates.TemplateResponse(\"index.html\", {\"request\": request})",
      "    else:",
      "        return HTMLResponse(\"NO GUI!\")",
      "",
      "",
      "@app.get(\"/version/\")",
      "def get_version() -> str:",
      "    \"\"\"Get the version of the application.\"\"\"",
      "    return app.version",
      "",
      "",
      "def start() -> None:",
      "    \"\"\"Run the FastAPI application.\"\"\"",
      "    if config.workers < 1:",
      "        # TODO",
      "        ncpu = os.cpu_count()",
      "        if ncpu is None:",
      "            workers = 1",
      "        else:",
      "            workers = (ncpu - 5) * 2 + 1",
      "    else:",
      "        workers = config.workers",
      "    uvicorn.run(",
      "        f\"src.{GitVersion.package_name()}.app.main:app\",",
      "        host=config.host,",
      "        port=config.port,",
      "        workers=workers,",
      "        log_config=CustomLogger.create_config(),  # type: ignore[call-arg],",
      "        log_level=config.log_level,",
      "        reload=False,",
      "    )",
      "",
      "",
      "def dev() -> None:",
      "    \"\"\"Run the FastAPI application in development mode.\"\"\"",
      "    src_dirpath = Path(\"../src\")",
      "    if not src_dirpath.exists():",
      "        includes = [src_dirpath.as_posix()]",
      "    else:",
      "        includes = []",
      "    uvicorn.run(",
      "        f\"src.{GitVersion.package_name()}.app.main:app\",",
      "        host=config.host,",
      "        port=config.port,",
      "        reload=True,",
      "        reload_includes=includes,",
      "        log_level=config.log_level,",
      "        workers=1,",
      "    )"
    ]
  },
  "FastAPI AppConfig": {
    "prefix": "py-app-config",
    "description": "FastAPI application configuration model.",
    "body": [
      "\"\"\"FastAPI application configuration model.\"\"\"",
      "",
      "from __future__ import annotations",
      "",
      "import json",
      "from pathlib import Path",
      "from typing import Literal",
      "",
      "from pydantic import BaseModel",
      "from pydantic import ConfigDict",
      "",
      "from ${1:package_name}.utils import FormatConverter",
      "",
      "",
      "class AppConfig(BaseModel):",
      "    \"\"\"Application configuration model.",
      "",
      "    Args:",
      "        host (str): Hostname for the application server.",
      "        port (int): Port number for the application server.",
      "        log_level (Literal[\"debug\", \"info\", \"warning\", \"error\"]):",
      "            Logging level for the application.",
      "    \"\"\"",
      "",
      "    model_config = ConfigDict(",
      "        alias_generator=FormatConverter.snake_to_camel, populate_by_name=True",
      "    )",
      "",
      "    host: str = \"localhost\"",
      "    port: int = 8000",
      "    log_level: Literal[\"debug\", \"info\", \"warning\", \"error\"] = \"info\"",
      "",
      "    @classmethod",
      "    def from_json(cls, config_json: dict) -> AppConfig:",
      "        \"\"\"Create an AppConfig instance from a JSON dictionary.\"\"\"",
      "        config = AppConfig.model_validate(config_json)",
      "        return config",
      "",
      "    @classmethod",
      "    def from_jsonfile(cls, config_file: str) -> AppConfig:",
      "        \"\"\"Create an AppConfig instance from a JSON file.\"\"\"",
      "        if not Path(config_file).exists():",
      "            raise FileNotFoundError(",
      "                f\"Configuration file {config_file} not found.\"",
      "            )",
      "        with open(config_file, \"r\") as file:",
      "            config_json = json.load(file)",
      "        return cls.from_json(config_json)",
      "",
      "    def to_jsonfile(self, config_file: str) -> None:",
      "        \"\"\"Save the AppConfig instance to a JSON file.\"\"\"",
      "        json_str = self.model_dump_json(indent=2, by_alias=True)",
      "        with open(config_file, \"w\") as fout:",
      "            fout.write(json_str)"
    ]
  },
  "CustomLogger": {
    "prefix": "py-logger",
    "description": "Custom logger module with refined format and color support.",
    "body": [
      "\"\"\"Custom logger module.\"\"\"",
      "",
      "import logging",
      "from logging import Formatter",
      "from logging import Logger",
      "from logging import StreamHandler",
      "from logging.handlers import RotatingFileHandler",
      "from pathlib import Path",
      "from typing import Literal",
      "",
      "",
      "class CustomLogger(Logger):",
      "    \"\"\"Custom logger class that has refined format.",
      "",
      "    Args:",
      "        name (str): Name of the logger.",
      "        stream_level (Literal[\"debug\", \"info\", \"warning\", \"error\"]):",
      "            Logging level for the stream handler.",
      "        file_level (Literal[\"debug\", \"info\", \"warning\", \"error\"]):",
      "            Logging level for the file handler.",
      "        log_filename (str): Path to the log file.",
      "        fmt_style (Literal[\"default\", \"detailed\"]):",
      "            Format style for log messages.",
      "        max_mb (int): Maximum size of the log file in MB before rotation.",
      "        backup_count (int): Number of backup files to keep.",
      "    \"\"\"",
      "",
      "    def __init__(",
      "        self,",
      "        name,",
      "        stream_level: Literal[\"debug\", \"info\", \"warning\", \"error\"],",
      "        file_level: Literal[\"debug\", \"info\", \"warning\", \"error\"],",
      "        log_filename: str,",
      "        fmt_style: Literal[\"default\", \"detailed\"] = \"default\",",
      "        max_mb: int = 10,",
      "        backup_count: int = 5,",
      "    ):",
      "        \"\"\"Initialize the custom logger.\"\"\"",
      "        super().__init__(name=name)",
      "        match fmt_style:",
      "            case \"default\":",
      "                fmt: str = \"%(levelname)s: \" + \"[%(asctime)s]\" + \" %(message)s\"",
      "                date_fmt = r\"%Y-%m-%d %H:%M:%S\"",
      "            case \"detailed\":",
      "                fmt = (",
      "                    \"[%(asctime)s.%(msecs)03d] %(levelname)-8s \"",
      "                    + \"%(filename)-12s:L %(lineno)-3d\"",
      "                    + \": %(message)s\"",
      "                )",
      "                date_fmt = r\"%Y-%m-%d %H:%M:%S\"",
      "        formatter = Formatter(fmt=fmt, datefmt=date_fmt)",
      "        color_formatter = ColorFormatter(fmt=fmt, datefmt=date_fmt)",
      "        stream_handler = StreamHandler()",
      "        stream_handler.setFormatter(color_formatter)",
      "        stream_handler.setLevel(stream_level)",
      "        self.addHandler(stream_handler)",
      "        if log_filename is not None:",
      "            log_filepath = Path(log_filename)",
      "            log_filepath.parent.mkdir(parents=True, exist_ok=True)",
      "            max_bytes = max_mb * 1024 * 1024  # 10 MB",
      "            file_handler = RotatingFileHandler(",
      "                log_filepath,",
      "                maxBytes=max_bytes,",
      "                backupCount=backup_count,",
      "                delay=True,",
      "            )",
      "            file_handler.setFormatter(formatter)",
      "            file_handler.setLevel(file_level)",
      "            self.addHandler(file_handler)",
      "",
      "    @staticmethod",
      "    def _get_package_name():",
      "        current_filepath = Path(__file__)",
      "        parents = list(current_filepath.parents)",
      "        package_name = current_filepath.name.replace(\".py\", \"\")",
      "        for parent in parents:",
      "            if (parent_name := parent.name) not in [\"src\", \"site-packages\"]:",
      "                package_name = parent_name + \".\" + package_name",
      "            else:",
      "                return package_name",
      "        raise RuntimeError(",
      "            \"Failed to determine package name. \"",
      "            + \" The package directory should be located in the \"",
      "            + \"`src` or `site-packages` directory.\"",
      "        )",
      "",
      "    @staticmethod",
      "    def create_config(",
      "        log_filename: str = \"log/app.log\",",
      "        max_mb: int = 100,",
      "        backup_count: int = 5,",
      "    ) -> dict:",
      "        \"\"\"Create a configuration dictionary for the logger.\"\"\"",
      "        package_name = CustomLogger._get_package_name()",
      "        dict_config = {",
      "            \"version\": 1,",
      "            \"formatters\": {",
      "                \"default\": {",
      "                    \"()\": f\"{package_name}.ColorFormatter\",",
      "                    \"format\": \"%(levelname)s: \"",
      "                    + \"[%(asctime)s]\"",
      "                    + \"%(message)s\",",
      "                    \"datefmt\": r\"%Y-%m-%d %H:%M:%S\",",
      "                },",
      "                \"detail\": {",
      "                    \"()\": f\"{package_name}.ColorFormatter\",",
      "                    \"format\": \"[%(asctime)s.%(msecs)03d]: %(levelname)-8s\"",
      "                    + \"%(filename)-16s:L %(lineno)-3d\"",
      "                    + \": %(message)s\",",
      "                    \"datefmt\": r\"%Y-%m-%d %H:%M:%S\",",
      "                },",
      "                \"defaultNoColor\": {",
      "                    \"format\": \"%(levelname)s: \"",
      "                    + \"[%(asctime)s]\"",
      "                    + \"%(message)s\",",
      "                    \"datefmt\": r\"%Y-%m-%d %H:%M:%S\",",
      "                },",
      "                \"detailNoColor\": {",
      "                    \"format\": \"[%(asctime)s.%(msecs)03d]: %(levelname)-8s\"",
      "                    + \"%(filename)-16s:L %(lineno)-3d\"",
      "                    + \": %(message)s\",",
      "                    \"datefmt\": r\"%Y-%m-%d %H:%M:%S\",",
      "                },",
      "            },",
      "            \"handlers\": {",
      "                \"stream\": {",
      "                    \"class\": \"logging.StreamHandler\",",
      "                    \"formatter\": \"default\",",
      "                },",
      "                \"file\": {",
      "                    \"class\": \"logging.handlers.RotatingFileHandler\",",
      "                    \"formatter\": \"defaultNoColor\",",
      "                    \"filename\": log_filename,",
      "                    \"maxBytes\": max_mb * 1024**2,",
      "                    \"backupCount\": backup_count,",
      "                    \"delay\": True,",
      "                },",
      "                \"streamDetail\": {",
      "                    \"class\": \"logging.StreamHandler\",",
      "                    \"formatter\": \"detail\",",
      "                },",
      "                \"fileDetail\": {",
      "                    \"class\": \"logging.handlers.RotatingFileHandler\",",
      "                    \"formatter\": \"detailNoColor\",",
      "                    \"filename\": log_filename,",
      "                    \"maxBytes\": max_mb * 1024**2,",
      "                    \"backupCount\": backup_count,",
      "                    \"delay\": True,",
      "                },",
      "            },",
      "            \"root\": {",
      "                \"level\": \"DEBUG\",",
      "                \"handlers\": [\"streamDetail\", \"fileDetail\"],",
      "                \"propagate\": False,",
      "            },",
      "            \"loggers\": {",
      "                \"detail\": {",
      "                    \"level\": \"DEBUG\",",
      "                    \"handlers\": [\"streamDetail\", \"fileDetail\"],",
      "                    \"propagate\": False,",
      "                },",
      "                \"uvicorn\": {",
      "                    \"level\": \"INFO\",",
      "                    \"handlers\": [\"streamDetail\", \"fileDetail\"],",
      "                    \"propagate\": False,",
      "                },",
      "            },",
      "        }",
      "        return dict_config",
      "",
      "",
      "class ColorFormatter(Formatter):",
      "    \"\"\"Custom formatter for colored log messages.\"\"\"",
      "",
      "    RESET = \"\\x1b[0m\"",
      "    RED = \"\\x1b[31m\"",
      "    GREEN = \"\\x1b[32m\"",
      "    YELLOW = \"\\x1b[33m\"",
      "    BLUE = \"\\x1b[34m\"",
      "    MAGENTA = \"\\x1b[35m\"",
      "    CYAN = \"\\x1b[36m\"",
      "    WHITE = \"\\x1b[37m\"",
      "    LEVEL_CORLORS = {",
      "        logging.DEBUG: BLUE,",
      "        logging.INFO: GREEN,",
      "        logging.WARNING: YELLOW,",
      "        logging.ERROR: RED,",
      "        logging.CRITICAL: MAGENTA,",
      "    }",
      "",
      "    def format(self, record: logging.LogRecord) -> str:",
      "        \"\"\"Format the log record with color.\"\"\"",
      "        original_level = record.levelname",
      "        color = self.LEVEL_CORLORS.get(record.levelno, self.RESET)",
      "        algined_levelname = f\"{record.levelname:<8}\"",
      "        record.levelname = f\"{color}{algined_levelname}{self.RESET}\"",
      "        formatted_message = super().format(record)",
      "        record.levelname = original_level  # Restore original level name",
      "        return formatted_message"
    ]
  },
  "pyproject": {
    "prefix": "py-pyproject",
    "description": "Snippet for pyproject",
    "body": [
      "[project]",
      "name = \"${1:package_name}\"",
      "description = \"\"",
      "readme = \"README.md\"",
      "requires-python = \">=3.13\"",
      "dependencies = []",
      "dynamic = [\"version\"]",
      "",
      "[project.scripts]",
      "",
      "[build-system]",
      "requires = [\"hatchling\", \"uv-dynamic-versioning\"]",
      "build-backend = \"hatchling.build\"",
      "",
      "[tool.hatch.version]",
      "source = \"uv-dynamic-versioning\"",
      "",
      "[tool.hatch.build.hooks.version]",
      "path = \"src/${1:package_name}/_version.py\"",
      "template = '''",
      "version = \"{version}\"",
      "'''",
      "",
      "[tool.isort]",
      "force_single_line = true",
      "",
      "[tool.mypy]",
      "ignore_missing_imports = true",
      "",
      "[tool.black]",
      "line-length = 79",
      "",
      "[tool.ruff]",
      "line-length = 79",
      "",
      "[tool.ruff.lint]",
      "select = [\"D\", \"E\", \"F\", \"C90\", \"I\"]",
      "fixable = [\"I\"]",
      "",
      "[tool.ruff.lint.isort]",
      "known-first-party = [\"${1:package_name}\"]",
      "section-order = [",
      "    \"future\",",
      "    \"standard-library\",",
      "    \"third-party\",",
      "    \"first-party\",",
      "    \"local-folder\",",
      "]",
      "force-single-line = true",
      "combine-as-imports = true",
      "from-first = false",
      "",
      "[tool.ruff.lint.pydocstyle]",
      "convention = \"google\"",
      "",
      "[tool.ruff.format]",
      "quote-style = \"double\"",
      "indent-style = \"space\"",
      "skip-magic-trailing-comma = false",
      "preview = false",
      "",
      "[tool.pytest.ini_options]",
      "minversion = \"6.0\"",
      "addopts = \"-v\"",
      "testpaths = [\"tests\"]"
    ]
  },
  "Class Formatconverter": {
    "prefix": "py-format-converter",
    "description": "Class definition for FormatConverter.",
    "body": [
      "\"\"\"Utility for converting string formats.\"\"\"",
      "",
      "",
      "class FormatConverter:",
      "    \"\"\"A utility class for converting string formats.\"\"\"",
      "",
      "    @staticmethod",
      "    def snake_to_camel(word: str) -> str:",
      "        \"\"\"Convert snake_case to camelCase.\"\"\"",
      "        components = word.split(\"_\")",
      "        return components[0] + \"\".join(x.capitalize() for x in components[1:])"
    ]
  }
}